* はじめに
こんにちは。κeenです。Lisp(主にCommon Lisp)とML(主にSML)が好きな人です。仕事ではScalaを書いてます。
新しい言語を始めるにあたって、ある程度まで進むと必要になってくる知識は「パッケージ管理をどうするか」及びそれに付随して「ビルドをどうするか」だと思います。
ということでSMLのパッケージ管理ツールのSmackageとビルドツールのsmbtを紹介したいと思います。

* SMLのコミュニティ事情
SMLはご存知の通りSML '90やSML '98の仕様を実装しているものならSMLになるので世の中に多数のSML処理系が存在します。
SMLはその仕様の厳密さからか研究用途で使われることが多いようで、処理系毎に研究の成果を反映した独自の機能を持っていてそれがSMLの魅力の1つでもあります。
しかしその反面ユーザーのコミュニティはあまり発達しなかったようで、継続的にSMLのライブラリを書いたり業務でSMLを使っている人はほぼ皆無なようです。
ただ、コミュニティがないかと言うとそういうこともなく、処理系の開発者などが集って作っているSML Familyというコミュニティが存在します。
http://sml-family.org/
https://github.com/SMLFamily

Family(語族)の名の通りSMLだけでなくSMLから派生して作られた言語も対象に入っているようです。
SMLの仕様書や後述するBasisライブラリのリファレンスなど多くのリソースをホストしている大事なコミュニティです。

さて、もう少しSMLを取り巻く環境について話していきましょう。

最近は仕様=処理系な言語が多いのであまり悩まされたことのない方も多いかと思いますが複数の処理系がある言語で問題になるのが互換性とどの処理系がメジャーかです。

** 互換性
処理系のAPIの互換性は高いと思っています。仕様で定められているコア言語以外にもBasisというライブラリがあって、大抵の処理系でその大部分を実装しています。
http://sml-family.org/Basis/
このBasisライブラリは中々優秀で、文字列やリストなどの基本操作からプロセスなどのOSインターフェースまで定義されています。
Basisライブラリを使っていればほとんどのことは出来るし、大抵の処理系でBasisライブラリを使えるという意味で互換性は高いと言えるでしょう。

ただしC FFIやスレッドなど処理系拡張に関しては中々処理系で統一されておらず、また、ビルドツールもコンディショナルビルドなどの処理系間の差異を吸収するようには作られていないのでBasisから外れたことをやろうとすると中々つらいことが多いです。

また、Basisライブラリは基本的で比較的低レベルな機能を提供することを目的としているので例えばMapやSetなどのデータ構造を定義しておらず、
自分のライブラリ達で使いたかったら処理系が独自に提供しているライブラリを使うかライブラリ毎にMapやSetを定義してそれを使うかになり、中々コードの再利用が進みません。
この問題に関しては先述のSML FamilyでBasisライブラリを拡充する計画があったり後述のパッケージ管理システムで共通化を図ったり改善の方向にあります。
SMLFamily/BasisLibrary
https://github.com/SMLFamily/BasisLibrary

API以外、例えばCLIなどは処理系毎に違いすぎて目も当てられない状況です。極端な話、SMLコア言語とBasisライブラリだけを使った処理系互換なプログラムを書いたとしても追加のコード無しに動かせる処理系はほとんどないでしょう。
処理系毎にビルド方法やビルド時の依存ファイルも違うしそもそもビルドという概念もない処理系もあるわプログラム実行時のエントリーポイントの指定方法も処理系依存だわでポータブルな書き方が存在しないのが現状です。

C言語では仕様では何もいってないけどGCCとClangがCLIを合わせてだいたい互換性を保ってますがそういう訳でもなくCommon LispのようにREPL内から使える汎用のビルドツールがある訳でもなくSMLではただ単にバラバラです。
仕様が言語のセマンティクスだけ定めて実行環境すら(コンパイラなのかインタプリタなのかREPLなのかなどなど)を定めなかったのでREPLでしか動かない処理系やコンパイラでしか動かない処理系が出てしまったのが原因かな、と思ってます。
さらに厄介なことにREPLオンリーとコンパイラオンリーが双璧を成す人気処理系というのも頭痛の種です。

** メジャーな処理系
先述した通り、メジャーなのはMLtonというコンパイラしかない処理系とSML of New Jersey(SML/NJ)というREPLしかない処理系です。

HaskellのGHC一強のようなことはなく、だいたいどちらも、あるいはその他の処理系も全てをサポートするライブラリが多いような印象を受けます。その辺はC言語に似ているでしょうか。

私は使い勝手から開発時はSML/NJ、完成品はMLtonのような使い方をするので必然的に両方の処理系をサポートすることになります。あるいはどちらでもない単体で使い勝手の良い処理系を使うか。

*** MLton
MLtonは高級言語とは思えない速度を出す非常に優れたコンパイラな反面、Whole Program Compilerで、極端な話1000個のファイルからなるプログラムのどれか1行でも変更したら1000個のファイル全てコンパイルし直しになる中々厳しいインターフェースを持っています。
また、コンパイルも割と遅く、小さなプログラムでもコンパイルに数秒を必要とします。Basisライブラリ毎コンパイルしてるからでしょうか。

繰り返しますがMLtonは本当に速いコードを吐くコンパイラで、ベンチマークでもC言語にも迫る勢いのスコアを出します。ベンチマークの時だけ高速に動いてるんじゃないかと思いたくなりますがVWが話題になるずっと前からこのスコアを出しているので実力でこの値です。

処理系独自の拡張も多彩でスレッドやC言語との相互連携、継続(callcc)などもサポートしています。

aobenchによるSMLベンチマークを書いた - ::Eldesh a b = LEFT a | RIGHT b
http://d.hatena.ne.jp/eldesh/20131213/1386907957

*** SML/NJ
SML/NJは内部的にはネイティブコードを吐くコンパイラですが実行形態としてはREPLしかサポートしていません。
Common Lispと同じくヒープイメージのダンプはサポートしていますがクロスビルドに難があったり実行時に必要のない機能までダンブする必要があったり使い勝手の良いものではありません。

速度に関してはMLtonこそ劣るもののそれでもその辺の言語処理系には負けない程度の速度を出しており、特に気にかける必要はないでしょう。
それより特筆すべきは拡張機能の豊富さです。文法拡張に始まり高階ファンクタやQuote/Antiquoteなど様々な拡張を用意しています。

*** 他の処理系たち
SML#はREPLとコンパイラ両方をサポートしており、分割コンパイル、簡単に書けるC FFIなど優れた機能があります。
スレッド機能としてはサポートしていませんがC FFIでpthreadを呼び出しても安全なのでそれを使うのを推奨するという中々すごいことをやっています。
他にも幾つか拡張機能はあるのですが中々に遅い処理系なのでそこが玉に瑕ですね。

Moscow MLは

github standardml
https://github.com/standardml/smackage
https://github.com/finrod/smbt


* Smackage
** 概念
** ソース
** ビルド
** 使い方
** SML/NJ
** MLton
** SML#
** 自前sourceの作り方

* SMLのビルド周り
つらいよねー。

* SMBT
** 機能紹介
** 記法
** サンプル

Smackage向けにパッケージ作るならsmbt使った方がいいよねって話。

PreMLと統合したら少し楽になるんじゃないって話。
